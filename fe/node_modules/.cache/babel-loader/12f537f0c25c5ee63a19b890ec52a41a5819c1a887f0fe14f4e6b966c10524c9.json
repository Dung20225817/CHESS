{"ast":null,"code":"// chessRules.ts (phiên bản multiplayer)\nexport function isValidMove(piece, r1, c1, r2, c2, board) {\n  const target = board[r2][c2];\n\n  // Không ăn quân cùng màu\n  if (piece === piece.toUpperCase() && target !== \".\" && target === target.toUpperCase()) return false;\n  if (piece === piece.toLowerCase() && target !== \".\" && target === target.toLowerCase()) return false;\n  const dr = r2 - r1;\n  const dc = c2 - c1;\n  switch (piece.toLowerCase()) {\n    case \"p\":\n      {\n        const direction = piece === \"P\" ? -1 : 1;\n        const startRow = piece === \"P\" ? 6 : 1;\n        if (c1 === c2 && dr === direction && target === \".\") return true;\n        if (c1 === c2 && r1 === startRow && dr === 2 * direction && board[r1 + direction][c1] === \".\" && board[r2][c2] === \".\") return true;\n        if (Math.abs(dc) === 1 && dr === direction && target !== \".\") return true;\n        return false;\n      }\n    case \"r\":\n      {\n        if (r1 === r2) {\n          const min = Math.min(c1, c2) + 1;\n          const max = Math.max(c1, c2);\n          for (let c = min; c < max; c++) if (board[r1][c] !== \".\") return false;\n          return true;\n        } else if (c1 === c2) {\n          const min = Math.min(r1, r2) + 1;\n          const max = Math.max(r1, r2);\n          for (let r = min; r < max; r++) if (board[r][c1] !== \".\") return false;\n          return true;\n        }\n        return false;\n      }\n    case \"n\":\n      return Math.abs(dr) === 2 && Math.abs(dc) === 1 || Math.abs(dr) === 1 && Math.abs(dc) === 2;\n    case \"b\":\n      if (Math.abs(dr) !== Math.abs(dc)) return false;\n      const stepR = dr > 0 ? 1 : -1;\n      const stepC = dc > 0 ? 1 : -1;\n      let r = r1 + stepR,\n        c = c1 + stepC;\n      while (r !== r2 && c !== c2) {\n        if (board[r][c] !== \".\") return false;\n        r += stepR;\n        c += stepC;\n      }\n      return true;\n    case \"q\":\n      // Dùng rook + bishop logic\n      return isValidMove(piece === \"Q\" ? \"R\" : \"r\", r1, c1, r2, c2, board) || isValidMove(piece === \"Q\" ? \"B\" : \"b\", r1, c1, r2, c2, board);\n    case \"k\":\n      // Chỉ cho di chuyển 1 ô\n      return Math.abs(dr) <= 1 && Math.abs(dc) <= 1;\n    default:\n      return false;\n  }\n}","map":{"version":3,"names":["isValidMove","piece","r1","c1","r2","c2","board","target","toUpperCase","toLowerCase","dr","dc","direction","startRow","Math","abs","min","max","c","r","stepR","stepC"],"sources":["D:/CHESS/fe/src/components/utils/chessRules.ts"],"sourcesContent":["// chessRules.ts (phiên bản multiplayer)\nexport function isValidMove(\n  piece: string,\n  r1: number,\n  c1: number,\n  r2: number,\n  c2: number,\n  board: string[][]\n): boolean {\n  const target = board[r2][c2];\n\n  // Không ăn quân cùng màu\n  if (piece === piece.toUpperCase() && target !== \".\" && target === target.toUpperCase()) return false;\n  if (piece === piece.toLowerCase() && target !== \".\" && target === target.toLowerCase()) return false;\n\n  const dr = r2 - r1;\n  const dc = c2 - c1;\n\n  switch (piece.toLowerCase()) {\n    case \"p\": {\n      const direction = piece === \"P\" ? -1 : 1;\n      const startRow = piece === \"P\" ? 6 : 1;\n      if (c1 === c2 && dr === direction && target === \".\") return true;\n      if (c1 === c2 && r1 === startRow && dr === 2 * direction && board[r1 + direction][c1] === \".\" && board[r2][c2] === \".\") return true;\n      if (Math.abs(dc) === 1 && dr === direction && target !== \".\") return true;\n      return false;\n    }\n    case \"r\": {\n      if (r1 === r2) {\n        const min = Math.min(c1, c2) + 1;\n        const max = Math.max(c1, c2);\n        for (let c = min; c < max; c++) if (board[r1][c] !== \".\") return false;\n        return true;\n      } else if (c1 === c2) {\n        const min = Math.min(r1, r2) + 1;\n        const max = Math.max(r1, r2);\n        for (let r = min; r < max; r++) if (board[r][c1] !== \".\") return false;\n        return true;\n      }\n      return false;\n    }\n    case \"n\":\n      return (Math.abs(dr) === 2 && Math.abs(dc) === 1) || (Math.abs(dr) === 1 && Math.abs(dc) === 2);\n    case \"b\":\n      if (Math.abs(dr) !== Math.abs(dc)) return false;\n      const stepR = dr > 0 ? 1 : -1;\n      const stepC = dc > 0 ? 1 : -1;\n      let r = r1 + stepR, c = c1 + stepC;\n      while (r !== r2 && c !== c2) {\n        if (board[r][c] !== \".\") return false;\n        r += stepR; c += stepC;\n      }\n      return true;\n    case \"q\":\n      // Dùng rook + bishop logic\n      return isValidMove(piece === \"Q\" ? \"R\" : \"r\", r1, c1, r2, c2, board) ||\n             isValidMove(piece === \"Q\" ? \"B\" : \"b\", r1, c1, r2, c2, board);\n    case \"k\":\n      // Chỉ cho di chuyển 1 ô\n      return Math.abs(dr) <= 1 && Math.abs(dc) <= 1;\n    default:\n      return false;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}